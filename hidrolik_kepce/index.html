<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mor Maker: Hidrolik Kep√ße</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Fredoka', sans-serif;
            background: #f39c12;
            user-select: none;
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #top-bar {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            color: #f1c40f;
            font-size: 24px;
            border-bottom: 4px solid #f1c40f;
        }

        .stat-box {
            background: #d35400;
            padding: 10px 20px;
            border-radius: 15px;
            border: 2px solid #f1c40f;
            color: white;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        #controls-panel {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 20px 20px 0 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.2);
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 600px;
        }

        .slider-label {
            width: 100px;
            font-weight: bold;
            color: #d35400;
        }

        input[type=range] {
            flex-grow: 1;
            height: 20px;
            -webkit-appearance: none;
            background: #eee;
            border-radius: 10px;
            border: 2px solid #ccc;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 30px;
            height: 30px;
            background: #f1c40f;
            border: 2px solid #d35400;
            border-radius: 50%;
            cursor: pointer;
        }

        .action-buttons {
            display: flex;
            gap: 20px;
        }

        .game-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 6px 0 #c0392b;
            transition: transform 0.1s;
            font-family: inherit;
            font-weight: bold;
        }

        .game-btn:active {
            transform: translateY(6px);
            box-shadow: none;
        }

        #magnet-btn {
            background: #3498db;
            box-shadow: 0 6px 0 #2980b9;
        }

        #magnet-btn.active {
            background: #2ecc71;
            box-shadow: 0 6px 0 #27ae60;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 50px;
            border-radius: 30px;
            text-align: center;
            display: none;
            pointer-events: auto;
            border: 8px solid #d35400;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }

        #game-over h1 {
            color: #d35400;
            font-size: 48px;
            margin: 0 0 20px;
        }

        .hidden {
            display: none !important;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>

    <div id="ui-container">
        <div id="top-bar">
            <div class="stat-box">üì¶ Ta≈üƒ±nan: <span id="score">0</span>/5</div>
            <div class="stat-box">‚è≥ S√ºre: <span id="time">120</span></div>
        </div>

        <div id="controls-panel">
            <div class="slider-group">
                <span class="slider-label">G√∂vde D√∂n√º≈ü</span>
                <input type="range" id="slider-base" min="-1.5" max="1.5" step="0.01" value="0">
            </div>
            <div class="slider-group">
                <span class="slider-label">Ana Kol</span>
                <input type="range" id="slider-boom" min="-0.5" max="1.0" step="0.01" value="0.7">
            </div>
            <div class="slider-group">
                <span class="slider-label">ƒ∞kinci Kol</span>
                <input type="range" id="slider-stick" min="-1.0" max="1.0" step="0.01" value="-0.5">
            </div>

            <div class="action-buttons">
                <button class="game-btn" id="magnet-btn">üß≤ MIKNATIS</button>
                <button class="game-btn" id="joker-btn" onclick="useJoker()">‚ö° S√úPER G√ú√á</button>
            </div>
        </div>
    </div>

    <div id="game-over">
        <h1>ƒ∞≈ü G√ºn√º Bitti!</h1>
        <p style="font-size: 24px;">Ta≈üƒ±nan Y√ºk: <span id="final-score">0</span></p>
        <button class="game-btn" onclick="location.reload()">Yeni ƒ∞≈ü ‚Ü∫</button>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // Game State
        let score = 0;
        let time = 120;
        let gameActive = true;
        let magnetActive = false;
        let grabbedObject = null;
        let jokerActive = false;

        // Three.js Setup
        let scene, camera, renderer;
        let baseGroup, bodyGroup, boomGroup, stickGroup, magnet;
        let boxes = [];
        let dropZone;

        // Control Values
        const controls = {
            base: 0,
            boom: 0.7,
            stick: -0.5
        };

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, 12, 15);
            camera.lookAt(0, 2, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.set(2048, 2048);
            scene.add(dirLight);

            createEnvironment();
            createExcavator();
            createBoxes();

            // Events
            setupUI();
            window.addEventListener('resize', onWindowResize);
        }

        function createEnvironment() {
            // Ground
            const groundGeo = new THREE.PlaneGeometry(100, 100);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x95a5a6 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Drop Zone
            const dropZoneGeo = new THREE.RingGeometry(3, 3.5, 32);
            const dropZoneMat = new THREE.MeshBasicMaterial({ color: 0x2ecc71, side: THREE.DoubleSide });
            dropZone = new THREE.Mesh(dropZoneGeo, dropZoneMat);
            dropZone.rotation.x = -Math.PI / 2;
            dropZone.position.set(-8, 0.02, -8);
            scene.add(dropZone);

            // Zone Marker
            const markerGeo = new THREE.CircleGeometry(3, 32);
            const markerMat = new THREE.MeshBasicMaterial({ color: 0x2ecc71, transparent: true, opacity: 0.3 });
            const marker = new THREE.Mesh(markerGeo, markerMat);
            marker.rotation.x = -Math.PI / 2;
            marker.position.set(-8, 0.01, -8);
            scene.add(marker);

            // Label
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256; canvas.height = 128;
            ctx.fillStyle = '#2ecc71';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("BIRAKMA", 128, 50);
            ctx.fillText("ALANI", 128, 100);
            const tex = new THREE.CanvasTexture(canvas);
            const label = new THREE.Mesh(new THREE.PlaneGeometry(4, 2), new THREE.MeshBasicMaterial({ map: tex, transparent: true }));
            label.rotation.x = -Math.PI / 2;
            label.position.set(-8, 0.05, -8);
            scene.add(label);
        }

        function createExcavator() {
            const yellowMat = new THREE.MeshStandardMaterial({ color: 0xf1c40f, roughness: 0.6 });
            const darkMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            const blackMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

            // Base Group (Tracks + Chassis)
            baseGroup = new THREE.Group();
            scene.add(baseGroup);

            // Tracks
            const trackGeo = new THREE.BoxGeometry(1, 1, 5);
            const leftTrack = new THREE.Mesh(trackGeo, blackMat);
            leftTrack.position.set(-1.5, 0.5, 0);
            baseGroup.add(leftTrack);

            const rightTrack = new THREE.Mesh(trackGeo, blackMat);
            rightTrack.position.set(1.5, 0.5, 0);
            baseGroup.add(rightTrack);

            // Chassis
            const chassis = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 4), darkMat);
            chassis.position.y = 1;
            baseGroup.add(chassis);

            // Body Group (Rotates Y)
            bodyGroup = new THREE.Group();
            bodyGroup.position.y = 1.25;
            baseGroup.add(bodyGroup);

            // Cabin
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2, 3), yellowMat);
            cabin.position.set(0, 1, 0);
            cabin.castShadow = true;
            bodyGroup.add(cabin);

            // Glass
            const glass = new THREE.Mesh(new THREE.BoxGeometry(2.6, 1, 1.5), new THREE.MeshStandardMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.6 }));
            glass.position.set(0, 1.5, 0.8);
            bodyGroup.add(glass);

            // Boom Group (Rotates X)
            boomGroup = new THREE.Group();
            boomGroup.position.set(0, 1, 1.5);
            bodyGroup.add(boomGroup);

            const boom = new THREE.Mesh(new THREE.BoxGeometry(0.8, 6, 0.8), yellowMat);
            boom.position.set(0, 3, 0);
            boom.castShadow = true;
            boomGroup.add(boom);

            // Stick Group (Rotates X)
            stickGroup = new THREE.Group();
            stickGroup.position.set(0, 6, 0);
            boomGroup.add(stickGroup);

            const stick = new THREE.Mesh(new THREE.BoxGeometry(0.6, 5, 0.6), yellowMat);
            stick.position.set(0, -2.5, 0); // Hangs down initially? Or forward.
            // Let's align stick forward
            stick.rotation.x = Math.PI / 2;
            stick.position.set(0, 0, 2.5);
            // Wait, standard excavator: Boom goes UP/FWD, Stick goes FWD/DOWN.
            // Let's keep simple hierarchy:
            // Boom pivot at bottom. Stick pivot at top of boom.
            // Stick geometry should extend from pivot.
            stickGroup.add(stick);

            // Magnet
            const magnetGeo = new THREE.CylinderGeometry(1.2, 1.2, 0.5, 16);
            const magnetMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            magnet = new THREE.Mesh(magnetGeo, magnetMat);
            magnet.position.set(0, 0, 5); // End of stick
            magnet.rotation.x = Math.PI / 2;
            stickGroup.add(magnet);
        }

        function createBoxes() {
            const boxGeo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const boxMat = new THREE.MeshStandardMaterial({ color: 0xe74c3c });

            for (let i = 0; i < 5; i++) {
                const box = new THREE.Mesh(boxGeo, boxMat);
                box.position.set(
                    5 + Math.random() * 8,
                    0.75,
                    5 + Math.random() * 8
                );
                box.castShadow = true;
                box.userData = { grabbed: false, delivered: false };
                scene.add(box);
                boxes.push(box);
            }
        }

        function setupUI() {
            const sBase = document.getElementById('slider-base');
            const sBoom = document.getElementById('slider-boom');
            const sStick = document.getElementById('slider-stick');
            const btnMagnet = document.getElementById('magnet-btn');

            sBase.addEventListener('input', (e) => controls.base = parseFloat(e.target.value));
            sBoom.addEventListener('input', (e) => controls.boom = parseFloat(e.target.value));
            sStick.addEventListener('input', (e) => controls.stick = parseFloat(e.target.value));

            btnMagnet.addEventListener('mousedown', toggleMagnet);
            btnMagnet.addEventListener('touchstart', (e) => { e.preventDefault(); toggleMagnet(); });
        }

        function toggleMagnet() {
            magnetActive = !magnetActive;
            const btn = document.getElementById('magnet-btn');

            if (magnetActive) {
                btn.classList.add('active');
                btn.innerText = "üß≤ MIKNATIS A√áIK";
                magnet.material.color.set(0xff0000);
                magnet.material.emissive.set(0x550000);
            } else {
                btn.classList.remove('active');
                btn.innerText = "üß≤ MIKNATIS";
                magnet.material.color.set(0x333333);
                magnet.material.emissive.set(0x000000);
                dropObject();
            }
        }

        function dropObject() {
            if (grabbedObject) {
                const worldPos = new THREE.Vector3();
                grabbedObject.getWorldPosition(worldPos);
                scene.attach(grabbedObject);
                grabbedObject.position.copy(worldPos);
                grabbedObject.userData.grabbed = false;

                // Check drop zone
                if (worldPos.distanceTo(dropZone.position) < 4) {
                    if (!grabbedObject.userData.delivered) {
                        grabbedObject.userData.delivered = true;
                        grabbedObject.material.color.set(0x2ecc71);
                        score++;
                        document.getElementById('score').innerText = score;
                        createParticles(worldPos);
                        if (score >= 5) endGame();
                    }
                }

                // Gravity fix
                if (grabbedObject.position.y > 0.75) {
                    // Simple tween drop
                    const startY = grabbedObject.position.y;
                    let t = 0;
                    const dropAnim = () => {
                        t += 0.1;
                        grabbedObject.position.y = THREE.MathUtils.lerp(startY, 0.75, t);
                        if (t < 1) requestAnimationFrame(dropAnim);
                    };
                    dropAnim();
                }

                grabbedObject = null;
            }
        }

        function createParticles(pos) {
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const mat = new THREE.MeshBasicMaterial({ color: 0x2ecc71 });
            for (let i = 0; i < 10; i++) {
                const p = new THREE.Mesh(geo, mat);
                p.position.copy(pos);
                p.position.y += 1;
                p.vel = new THREE.Vector3((Math.random() - 0.5), Math.random(), (Math.random() - 0.5)).multiplyScalar(0.2);
                scene.add(p);

                // Simple physics loop for particles
                let life = 30;
                const anim = () => {
                    life--;
                    p.position.add(p.vel);
                    p.vel.y -= 0.01;
                    if (life > 0) requestAnimationFrame(anim);
                    else scene.remove(p);
                };
                anim();
            }
        }

        window.useJoker = function () {
            if (!gameActive || jokerActive) return;
            jokerActive = true;
            const btn = document.getElementById('joker-btn');
            btn.style.opacity = 0.5;
            btn.innerText = "‚ö° AKTƒ∞F!";

            // Auto grab nearest
            magnetActive = true;
            document.getElementById('magnet-btn').classList.add('active');

            setTimeout(() => {
                jokerActive = false;
                btn.style.opacity = 1;
                btn.innerText = "‚ö° S√úPER G√ú√á";
            }, 5000);
        }

        function endGame() {
            gameActive = false;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').innerText = score;
        }

        // Timer
        setInterval(() => {
            if (gameActive && time > 0) {
                time--;
                document.getElementById('time').innerText = time;
                if (time <= 0) endGame();
            }
        }, 1000);

        function animate() {
            requestAnimationFrame(animate);

            if (gameActive) {
                // Smoothly interpolate rotations to slider values
                bodyGroup.rotation.y += (controls.base - bodyGroup.rotation.y) * 0.1;
                boomGroup.rotation.x += (controls.boom - boomGroup.rotation.x) * 0.1;
                stickGroup.rotation.x += (controls.stick - stickGroup.rotation.x) * 0.1;

                // Magnet Logic
                if (magnetActive && !grabbedObject) {
                    const magnetPos = new THREE.Vector3();
                    magnet.getWorldPosition(magnetPos);

                    const grabDist = jokerActive ? 6 : 2.5;
                    let nearestBox = null;
                    let minDst = Infinity;

                    boxes.forEach(box => {
                        if (!box.userData.grabbed && !box.userData.delivered) {
                            const dst = magnetPos.distanceTo(box.position);
                            if (dst < grabDist && dst < minDst) {
                                minDst = dst;
                                nearestBox = box;
                            }
                        }
                    });

                    if (nearestBox) {
                        grabbedObject = nearestBox;
                        grabbedObject.userData.grabbed = true;
                        magnet.attach(grabbedObject);
                        grabbedObject.position.set(0, 0, 1.5); // Offset from magnet center
                    }
                }
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>

</html>