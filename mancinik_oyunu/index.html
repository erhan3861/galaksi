<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <title>Mor Maker: Mancƒ±nƒ±k Kalesi</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'MedievalSharp', cursive;
            user-select: none;
            touch-action: none;
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #top-bar {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 20px;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8), transparent);
            color: #f1c40f;
            font-size: 28px;
            text-shadow: 2px 2px 0 #000;
        }

        .stat-box {
            background: rgba(142, 68, 173, 0.6);
            padding: 10px 25px;
            border-radius: 10px;
            border: 2px solid #f1c40f;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }

        #controls {
            pointer-events: auto;
            display: flex;
            justify-content: center;
            padding: 30px;
        }

        .game-btn {
            background: #c0392b;
            color: #f1c40f;
            border: 3px solid #f1c40f;
            padding: 15px 40px;
            font-size: 24px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'MedievalSharp', cursive;
            box-shadow: 0 5px 0 #7f2b22;
            transition: transform 0.1s;
            text-transform: uppercase;
        }

        .game-btn:active {
            transform: translateY(4px);
            box-shadow: 0 1px 0 #7f2b22;
        }

        #joker-btn {
            background: #2980b9;
            border-color: #3498db;
            position: absolute;
            right: 20px;
            bottom: 20px;
            font-size: 18px;
            padding: 10px 20px;
        }

        #game-over,
        #win-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 50px;
            border-radius: 20px;
            text-align: center;
            border: 5px solid #f1c40f;
            display: none;
            pointer-events: auto;
            color: #f1c40f;
            box-shadow: 0 0 50px rgba(241, 196, 15, 0.5);
        }

        #aim-hint {
            position: absolute;
            bottom: 150px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 24px;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }

        .hidden {
            display: none !important;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
                "canvas-confetti": "https://cdn.skypack.dev/canvas-confetti"
            }
        }
    </script>
</head>

<body>

    <div id="ui-container">
        <div id="top-bar">
            <div class="stat-box">üè∞ Puan: <span id="score">0</span></div>
            <div class="stat-box">üí£ Toplar: <span id="ammo">5</span></div>
        </div>

        <div id="aim-hint">Ekrana dokun ve geri √ßekerek ni≈üan al! üèπ</div>

        <div id="controls">
            <button class="game-btn" id="joker-btn" onclick="useJoker()">üî• Alev Topu</button>
        </div>
    </div>

    <div id="game-over">
        <h1>Oyun Bitti!</h1>
        <p style="font-size: 24px;">Skorun: <span id="final-score">0</span></p>
        <button class="game-btn" onclick="location.reload()">Tekrar Dene</button>
    </div>

    <div id="win-screen" class="hidden">
        <h1>Zafer! üèÜ</h1>
        <p style="font-size: 24px;">Kaleyi yƒ±ktƒ±n!</p>
        <button class="game-btn" onclick="location.reload()">Tekrar Oyna</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';
        import confetti from 'canvas-confetti';

        // Game State
        let score = 0;
        let ammo = 5;
        let gameActive = true;
        let jokerActive = false;
        let isDragging = false;
        let dragStart = new THREE.Vector2();
        let dragCurrent = new THREE.Vector2();

        // Three.js & Cannon.js Setup
        let scene, camera, renderer, world;
        let catapultBase, catapultArm, cup;
        let projectileMesh, projectileBody;
        let targets = [];
        let trajectoryLine;

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 15);
            camera.lookAt(0, 2, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('ui-container').appendChild(renderer.domElement); // Append behind UI

            // Physics World
            world = new CANNON.World();
            world.gravity.set(0, -9.8, 0);

            // Materials
            const defaultMaterial = new CANNON.Material('default');
            const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
                friction: 0.4,
                restitution: 0.3,
            });
            world.addContactMaterial(defaultContactMaterial);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // Ground
            const groundGeo = new THREE.PlaneGeometry(100, 100);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x55aa55 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const groundBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Plane(),
                material: defaultMaterial
            });
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);

            createCatapult();
            createCastle();
            createTrajectoryLine();

            // Input Events
            window.addEventListener('mousedown', onDragStart);
            window.addEventListener('mousemove', onDragMove);
            window.addEventListener('mouseup', onDragEnd);

            window.addEventListener('touchstart', e => {
                e.preventDefault();
                onDragStart(e.touches[0]);
            }, { passive: false });
            window.addEventListener('touchmove', e => {
                e.preventDefault();
                onDragMove(e.touches[0]);
            }, { passive: false });
            window.addEventListener('touchend', onDragEnd);

            window.addEventListener('resize', onWindowResize);

            window.useJoker = useJoker;
        }

        function createCatapult() {
            const group = new THREE.Group();
            group.position.set(0, 0, 8);
            scene.add(group);

            const woodMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });

            // Base
            const base = new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 5), woodMat);
            base.position.y = 0.25;
            base.castShadow = true;
            group.add(base);

            // Uprights
            const p1 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 2.5, 0.4), woodMat);
            p1.position.set(-1, 1.25, 0);
            p1.castShadow = true;
            group.add(p1);

            const p2 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 2.5, 0.4), woodMat);
            p2.position.set(1, 1.25, 0);
            p2.castShadow = true;
            group.add(p2);

            // Arm Pivot
            const pivot = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 2.5), new THREE.MeshStandardMaterial({ color: 0x555555 }));
            pivot.rotation.z = Math.PI / 2;
            pivot.position.set(0, 2.2, 0);
            group.add(pivot);

            // Arm
            catapultArm = new THREE.Group();
            catapultArm.position.set(0, 2.2, 0);
            group.add(catapultArm);

            const beam = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 4.5), woodMat);
            beam.position.set(0, 0, 1); // Pivot is near one end
            beam.castShadow = true;
            catapultArm.add(beam);

            // Cup
            cup = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.4, 0.5, 16), woodMat);
            cup.position.set(0, 0.4, 3);
            cup.castShadow = true;
            catapultArm.add(cup);

            // Counterweight
            const weight = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshStandardMaterial({ color: 0x444444 }));
            weight.position.set(0, -0.5, -1);
            catapultArm.add(weight);

            catapultArm.rotation.x = -Math.PI / 8; // Resting pos
        }

        function createCastle() {
            const stoneMat = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.8 });
            const boxSize = 1.0;
            const startZ = -10;

            // Create a wall of boxes
            for (let y = 0; y < 4; y++) {
                for (let x = -2; x <= 2; x++) {
                    // Skip some to make it look like a castle
                    if (y === 3 && (x === -1 || x === 1)) continue;

                    const mesh = new THREE.Mesh(new THREE.BoxGeometry(boxSize, boxSize, boxSize), stoneMat);
                    mesh.position.set(x * boxSize, y * boxSize + 0.5, startZ);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    scene.add(mesh);

                    const shape = new CANNON.Box(new CANNON.Vec3(boxSize / 2, boxSize / 2, boxSize / 2));
                    const body = new CANNON.Body({ mass: 1.0 });
                    body.addShape(shape);
                    body.position.copy(mesh.position);
                    world.addBody(body);

                    targets.push({ mesh, body, hit: false });
                }
            }
        }

        function createTrajectoryLine() {
            const points = [];
            for (let i = 0; i < 20; i++) points.push(new THREE.Vector3());
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const mat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
            trajectoryLine = new THREE.Line(geo, mat);
            trajectoryLine.visible = false;
            scene.add(trajectoryLine);
        }

        function updateTrajectory(velocity) {
            const points = [];
            const startPos = new THREE.Vector3(0, 2.5, 11); // Approx launch pos
            const g = new THREE.Vector3(0, -9.8, 0);

            for (let i = 0; i < 20; i++) {
                const t = i * 0.1;
                const pos = startPos.clone()
                    .add(velocity.clone().multiplyScalar(t))
                    .add(g.clone().multiplyScalar(0.5 * t * t));
                points.push(pos);
            }
            trajectoryLine.geometry.setFromPoints(points);
            trajectoryLine.visible = true;
        }

        function onDragStart(event) {
            if (!gameActive || ammo <= 0 || projectileBody) return;
            isDragging = true;
            dragStart.set(event.clientX, event.clientY);
            document.getElementById('aim-hint').style.opacity = 0;
        }

        function onDragMove(event) {
            if (!isDragging) return;
            dragCurrent.set(event.clientX, event.clientY);

            const delta = new THREE.Vector2().subVectors(dragCurrent, dragStart);
            // Pull back (down/positive Y in screen) -> Launch forward (negative Z)
            // Drag left/right -> Launch angle

            const power = Math.min(delta.y * 0.1, 20); // Max power
            if (power < 0) return; // Can't push forward to launch

            const angle = delta.x * 0.01;

            // Calculate launch velocity vector
            // Forward is -Z
            const launchVel = new THREE.Vector3(Math.sin(angle), 0.5, -Math.cos(angle)).multiplyScalar(power + 5);

            updateTrajectory(launchVel);

            // Visual arm rotation
            catapultArm.rotation.x = -Math.PI / 8 + (power * 0.05);
        }

        function onDragEnd() {
            if (!isDragging) return;
            isDragging = false;
            trajectoryLine.visible = false;

            const delta = new THREE.Vector2().subVectors(dragCurrent, dragStart);
            const power = Math.min(delta.y * 0.1, 20);

            if (power > 2) {
                const angle = delta.x * 0.01;
                const launchVel = new THREE.Vector3(Math.sin(angle), 0.8, -Math.cos(angle)).normalize().multiplyScalar(power + 10);
                fire(launchVel);
            } else {
                // Cancel
                catapultArm.rotation.x = -Math.PI / 8;
            }
        }

        function fire(velocity) {
            ammo--;
            document.getElementById('ammo').innerText = ammo;

            // Create Projectile
            const radius = jokerActive ? 0.6 : 0.3;
            const mass = jokerActive ? 50 : 5;
            const color = jokerActive ? 0xff4500 : 0x333333;

            const geo = new THREE.SphereGeometry(radius);
            const mat = new THREE.MeshStandardMaterial({ color: color });
            projectileMesh = new THREE.Mesh(geo, mat);
            projectileMesh.castShadow = true;

            // Start at cup position (approx)
            // Need to calculate exact world pos of cup
            // Simplified: Hardcoded launch pos relative to arm
            const startPos = new THREE.Vector3(0, 3, 10);
            projectileMesh.position.copy(startPos);
            scene.add(projectileMesh);

            const shape = new CANNON.Sphere(radius);
            projectileBody = new CANNON.Body({ mass: mass, shape: shape });
            projectileBody.position.copy(startPos);
            projectileBody.velocity.set(velocity.x, velocity.y, velocity.z);
            world.addBody(projectileBody);

            // Snap arm forward
            catapultArm.rotation.x = -Math.PI / 4;
            setTimeout(() => {
                // Reset arm slowly
                const interval = setInterval(() => {
                    catapultArm.rotation.x += 0.05;
                    if (catapultArm.rotation.x >= -Math.PI / 8) {
                        catapultArm.rotation.x = -Math.PI / 8;
                        clearInterval(interval);
                    }
                }, 20);
            }, 200);

            // Joker reset
            if (jokerActive) {
                jokerActive = false;
                document.getElementById('joker-btn').style.opacity = 1;
            }
        }

        function useJoker() {
            if (!gameActive || jokerActive) return;
            jokerActive = true;
            document.getElementById('joker-btn').style.opacity = 0.5;
        }

        function checkWin() {
            // Check if all targets are knocked down (y < 0.5 or moved significantly)
            let activeTargets = 0;
            targets.forEach(t => {
                if (t.body.position.y > 0.5) activeTargets++;
            });

            if (activeTargets === 0) {
                gameActive = false;
                document.getElementById('win-screen').classList.remove('hidden');
                confetti();
            } else if (ammo === 0 && !projectileBody) {
                // Wait a bit to see if physics settles
                setTimeout(() => {
                    if (activeTargets > 0) {
                        gameActive = false;
                        document.getElementById('final-score').innerText = score;
                        document.getElementById('game-over').style.display = 'block';
                    }
                }, 3000);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const dt = 1 / 60;
            world.step(dt);

            // Sync physics
            targets.forEach(t => {
                t.mesh.position.copy(t.body.position);
                t.mesh.quaternion.copy(t.body.quaternion);

                // Score update if knocked over
                if (!t.hit && (t.body.position.y < 0.2 || Math.abs(t.body.position.z - (-10)) > 2)) {
                    t.hit = true;
                    score += 100;
                    document.getElementById('score').innerText = score;
                }
            });

            if (projectileBody) {
                projectileMesh.position.copy(projectileBody.position);
                projectileMesh.quaternion.copy(projectileBody.quaternion);

                // Remove if out of bounds or stopped
                if (projectileBody.position.y < -10 || projectileBody.position.z < -50) {
                    world.removeBody(projectileBody);
                    scene.remove(projectileMesh);
                    projectileBody = null;
                    projectileMesh = null;
                    checkWin();
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>

</html>