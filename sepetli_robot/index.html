<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sepetli Robot - Toplayƒ±cƒ±</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Fredoka', sans-serif;
            background-color: #87CEEB;
            user-select: none;
            touch-action: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .score-board {
            background: rgba(255, 255, 255, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            border: 3px solid #FF9F1C;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.1);
            font-size: 24px;
            color: #333;
        }

        #joystick-zone {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
        }

        #start-screen,
        #win-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            color: white;
            text-align: center;
        }

        .big-btn {
            background: #8AC926;
            color: white;
            border: none;
            padding: 15px 50px;
            font-size: 2rem;
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Fredoka', sans-serif;
            margin-top: 20px;
            box-shadow: 0 6px 0 #5A8C12;
            transition: transform 0.1s;
        }

        .big-btn:active {
            transform: translateY(6px);
            box-shadow: none;
        }

        .hidden {
            display: none !important;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
                "canvas-confetti": "https://cdn.skypack.dev/canvas-confetti",
                "nipplejs": "https://cdn.skypack.dev/nipplejs"
            }
        }
    </script>
</head>

<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div class="header">
            <div class="score-board">üçé Toplanan: <span id="score">0</span>/5</div>
        </div>

        <div id="joystick-zone"></div>
    </div>

    <div id="start-screen">
        <h1 style="font-size: 4rem; margin: 0; color: #FFD97D; text-shadow: 4px 4px 0 #FF9F1C;">Sepetli Robot</h1>
        <p style="font-size: 1.5rem;">Elmalarƒ± topla, sepete doldur!</p>
        <button class="big-btn" id="start-btn">BA≈ûLA ‚ñ∂</button>
    </div>

    <div id="win-screen" class="hidden">
        <h1 style="font-size: 4rem; color: #8AC926;">TEBRƒ∞KLER! üéâ</h1>
        <p style="font-size: 1.5rem;">B√ºt√ºn elmalarƒ± topladƒ±n!</p>
        <button class="big-btn" id="restart-btn">TEKRAR OYNA ‚Ü∫</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';
        import confetti from 'canvas-confetti';
        import nipplejs from 'nipplejs';

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, world;
        let robotBody, robotMesh;
        let vehicle; // RaycastVehicle
        let items = [];
        let score = 0;
        const maxItems = 5;
        let isGameActive = false;

        // Input State
        const input = { up: false, down: false, left: false, right: false };

        init();
        animate();

        function init() {
            // 1. SCENE SETUP
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 20);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // LIGHTS
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.set(2048, 2048);
            scene.add(dirLight);

            // 2. PHYSICS WORLD
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.NaiveBroadphase();

            // MATERIALS
            const groundMat = new CANNON.Material();
            const wheelMat = new CANNON.Material();

            const wheelGroundContact = new CANNON.ContactMaterial(wheelMat, groundMat, {
                friction: 0.3,
                restitution: 0,
                contactEquationStiffness: 1000
            });
            world.addContactMaterial(wheelGroundContact);

            // 3. CREATE OBJECTS
            createGround(groundMat);
            createRobot(wheelMat);
            spawnItems();

            // Trees
            for (let i = 0; i < 20; i++) {
                createTree((Math.random() - 0.5) * 80, (Math.random() - 0.5) * 80);
            }

            // 4. EVENTS
            setupInputs();
            window.addEventListener('resize', onWindowResize);
            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('restart-btn').addEventListener('click', restartGame);
        }

        function createTree(x, z) {
            const group = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.8, 2), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
            trunk.position.y = 1;
            trunk.castShadow = true;
            group.add(trunk);

            const leaves = new THREE.Mesh(new THREE.ConeGeometry(2, 4), new THREE.MeshStandardMaterial({ color: 0x228B22 }));
            leaves.position.y = 3;
            leaves.castShadow = true;
            group.add(leaves);

            group.position.set(x, 0, z);
            scene.add(group);

            // Physics for tree (Static Box)
            const shape = new CANNON.Box(new CANNON.Vec3(0.5, 2, 0.5));
            const body = new CANNON.Body({ mass: 0 });
            body.addShape(shape);
            body.position.set(x, 2, z);
            world.addBody(body);
        }

        function createGround(material) {
            // Visual
            const geo = new THREE.PlaneGeometry(100, 100);
            const mat = new THREE.MeshStandardMaterial({ color: 0x90EE90 }); // Light Green
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI / 2;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // Physics
            const body = new CANNON.Body({ mass: 0, material: material });
            body.addShape(new CANNON.Plane());
            body.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            world.addBody(body);
        }

        function createRobot(wheelMaterial) {
            // Robot Chassis Dimensions
            const chassisShape = new CANNON.Box(new CANNON.Vec3(1.5, 0.5, 2.5));
            const chassisBody = new CANNON.Body({ mass: 150 });
            // FIX: Lower center of mass (0.5 instead of 1)
            chassisBody.addShape(chassisShape, new CANNON.Vec3(0, 0.5, 0));
            chassisBody.position.set(0, 4, 0);
            chassisBody.angularDamping = 0.5;

            // Visual Chassis (Wood)
            const chassisGeo = new THREE.BoxGeometry(3, 1, 5);
            const woodMat = new THREE.MeshStandardMaterial({ color: 0xDEB887 });
            robotMesh = new THREE.Mesh(chassisGeo, woodMat);
            robotMesh.castShadow = true;
            scene.add(robotMesh);

            // Basket (Sepet) on top
            const basketGroup = new THREE.Group();
            const basketMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });

            // Basket walls
            const w1 = new THREE.Mesh(new THREE.BoxGeometry(2.8, 1.5, 0.2), basketMat); w1.position.set(0, 0.75, -2.4);
            const w2 = new THREE.Mesh(new THREE.BoxGeometry(2.8, 1.5, 0.2), basketMat); w2.position.set(0, 0.75, 2.4);
            const w3 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.5, 5), basketMat); w3.position.set(-1.4, 0.75, 0);
            const w4 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.5, 5), basketMat); w4.position.set(1.4, 0.75, 0);

            basketGroup.add(w1, w2, w3, w4);
            basketGroup.position.y = 0.5; // On top of chassis
            robotMesh.add(basketGroup);

            // FIX: Eyes (Visual Polish)
            const eyeGeo = new THREE.SphereGeometry(0.25, 16, 16);
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const pupilGeo = new THREE.SphereGeometry(0.1, 16, 16);
            const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000 });

            const leftEye = new THREE.Group();
            const le = new THREE.Mesh(eyeGeo, eyeMat);
            const lp = new THREE.Mesh(pupilGeo, pupilMat);
            lp.position.z = -0.2;
            leftEye.add(le, lp);
            leftEye.position.set(0.8, 0, -2.5); // Front is -Z

            const rightEye = leftEye.clone();
            rightEye.position.set(-0.8, 0, -2.5);

            robotMesh.add(leftEye, rightEye);

            robotBody = chassisBody;
            world.addBody(robotBody);

            // Vehicle Setup
            vehicle = new CANNON.RaycastVehicle({
                chassisBody: chassisBody,
            });

            const wheelOptions = {
                radius: 0.8,
                directionLocal: new CANNON.Vec3(0, -1, 0),
                suspensionStiffness: 30,
                suspensionRestLength: 0.3,
                frictionSlip: 1.4,
                dampingRelaxation: 2.3,
                dampingCompression: 4.4,
                maxSuspensionForce: 100000,
                rollInfluence: 0.01,
                axleLocal: new CANNON.Vec3(1, 0, 0),
                chassisConnectionPointLocal: new CANNON.Vec3(1, 1, 0),
                maxSuspensionTravel: 0.3,
                customSlidingRotationalSpeed: -30,
                useCustomSlidingRotationalSpeed: true
            };

            // Add Wheels
            const axleWidth = 1.8;
            const axleLen = 2.5;

            // Front Left
            wheelOptions.chassisConnectionPointLocal.set(axleWidth, 0, -axleLen);
            vehicle.addWheel(wheelOptions);
            // Front Right
            wheelOptions.chassisConnectionPointLocal.set(-axleWidth, 0, -axleLen);
            vehicle.addWheel(wheelOptions);
            // Back Left
            wheelOptions.chassisConnectionPointLocal.set(axleWidth, 0, axleLen);
            vehicle.addWheel(wheelOptions);
            // Back Right
            wheelOptions.chassisConnectionPointLocal.set(-axleWidth, 0, axleLen);
            vehicle.addWheel(wheelOptions);

            vehicle.addToWorld(world);

            // Wheel Visuals
            const wheelBodies = [];
            vehicle.wheelInfos.forEach((wheel) => {
                const cylinderShape = new CANNON.Cylinder(wheel.radius, wheel.radius, wheel.radius / 2, 20);
                const wheelBody = new CANNON.Body({ mass: 0 });
                wheelBody.type = CANNON.Body.KINEMATIC;
                wheelBody.collisionFilterGroup = 0; // Turn off collisions
                const q = new CANNON.Quaternion();
                q.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
                wheelBody.addShape(cylinderShape, new CANNON.Vec3(), q);
                wheelBodies.push(wheelBody);

                // Visual Mesh
                const wGeo = new THREE.CylinderGeometry(wheel.radius, wheel.radius, wheel.radius / 2, 20);
                const wMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const wMesh = new THREE.Mesh(wGeo, wMat);
                wMesh.rotation.z = Math.PI / 2;
                wMesh.castShadow = true;
                scene.add(wMesh);
                wheel.mesh = wMesh;
            });

            // Update wheel visuals in animate loop
            world.addEventListener('postStep', () => {
                for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                    vehicle.updateWheelTransform(i);
                    const t = vehicle.wheelInfos[i].worldTransform;
                    const wheelMesh = vehicle.wheelInfos[i].mesh;
                    wheelMesh.position.copy(t.position);
                    wheelMesh.quaternion.copy(t.quaternion);
                }
            });
        }

        function spawnItems() {
            // Clear old items
            items.forEach(item => {
                scene.remove(item.mesh);
                world.removeBody(item.body);
            });
            items = [];

            const appleGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const appleMat = new THREE.MeshStandardMaterial({ color: 0xFF0000 });

            for (let i = 0; i < maxItems; i++) {
                const x = (Math.random() - 0.5) * 40;
                const z = (Math.random() - 0.5) * 40;

                const mesh = new THREE.Mesh(appleGeo, appleMat);
                mesh.position.set(x, 1, z);
                mesh.castShadow = true;
                scene.add(mesh);

                const shape = new CANNON.Sphere(0.5);
                const body = new CANNON.Body({ mass: 1, shape: shape });
                body.position.set(x, 5, z); // Drop from sky
                world.addBody(body);

                items.push({ mesh, body, collected: false });
            }
        }

        function setupInputs() {
            document.addEventListener('keydown', (e) => {
                switch (e.key) {
                    case 'ArrowUp': input.up = true; break;
                    case 'ArrowDown': input.down = true; break;
                    case 'ArrowLeft': input.left = true; break;
                    case 'ArrowRight': input.right = true; break;
                }
            });
            document.addEventListener('keyup', (e) => {
                switch (e.key) {
                    case 'ArrowUp': input.up = false; break;
                    case 'ArrowDown': input.down = false; break;
                    case 'ArrowLeft': input.left = false; break;
                    case 'ArrowRight': input.right = false; break;
                }
            });

            // Joystick
            const manager = nipplejs.create({
                zone: document.getElementById('joystick-zone'),
                mode: 'static',
                position: { left: '50%', top: '50%' },
                color: 'white'
            });

            manager.on('move', (evt, data) => {
                if (data && data.vector) {
                    // Map joystick to input
                    const x = data.vector.x;
                    const y = data.vector.y;

                    input.up = y > 0.3;
                    input.down = y < -0.3;
                    input.left = x < -0.3;
                    input.right = x > 0.3;
                }
            });

            manager.on('end', () => {
                input.up = false;
                input.down = false;
                input.left = false;
                input.right = false;
            });
        }

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            isGameActive = true;
            score = 0;
            document.getElementById('score').innerText = score;

            // FIX: Clear collected apples from robot mesh
            for (let i = robotMesh.children.length - 1; i >= 0; i--) {
                if (robotMesh.children[i].userData.isCollectedApple) {
                    robotMesh.remove(robotMesh.children[i]);
                }
            }

            spawnItems();
            // Reset Robot
            robotBody.position.set(0, 4, 0);
            robotBody.quaternion.set(0, 0, 0, 1);
            robotBody.velocity.set(0, 0, 0);
            robotBody.angularVelocity.set(0, 0, 0);
        }

        function restartGame() {
            document.getElementById('win-screen').classList.add('hidden');
            startGame();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const dt = 1 / 60;
            world.step(dt);

            if (isGameActive) {
                // Vehicle Control
                const maxSteerVal = 0.5;
                const maxForce = 100;
                const brakeForce = 10;

                // Steering
                if (input.left) {
                    vehicle.setSteeringValue(maxSteerVal, 0);
                    vehicle.setSteeringValue(maxSteerVal, 1);
                } else if (input.right) {
                    vehicle.setSteeringValue(-maxSteerVal, 0);
                    vehicle.setSteeringValue(-maxSteerVal, 1);
                } else {
                    vehicle.setSteeringValue(0, 0);
                    vehicle.setSteeringValue(0, 1);
                }

                // Engine
                if (input.up) {
                    vehicle.applyEngineForce(-maxForce, 2);
                    vehicle.applyEngineForce(-maxForce, 3);
                } else if (input.down) {
                    vehicle.applyEngineForce(maxForce, 2);
                    vehicle.applyEngineForce(maxForce, 3);
                } else {
                    vehicle.applyEngineForce(0, 2);
                    vehicle.applyEngineForce(0, 3);
                }

                // Sync Robot Mesh
                robotMesh.position.copy(robotBody.position);
                robotMesh.quaternion.copy(robotBody.quaternion);

                // Camera Follow
                const relativeCameraOffset = new THREE.Vector3(0, 10, 15);
                const cameraOffset = relativeCameraOffset.applyMatrix4(robotMesh.matrixWorld);
                camera.position.lerp(cameraOffset, 0.1);
                camera.lookAt(robotMesh.position);

                // Item Collection Logic
                items.forEach(item => {
                    if (!item.collected) {
                        // FIX: Spin Apple
                        item.mesh.rotation.y += 0.05;

                        // Sync Mesh
                        item.mesh.position.copy(item.body.position);
                        item.mesh.quaternion.copy(item.body.quaternion);

                        // Check Distance to Robot
                        const dist = item.body.position.distanceTo(robotBody.position);
                        if (dist < 3) {
                            // Collect!
                            item.collected = true;
                            score++;
                            document.getElementById('score').innerText = score;

                            // Visual effect: Jump into basket (Fake it by attaching to robot mesh or just removing)
                            // For simplicity: Remove physics, attach mesh to robot
                            world.removeBody(item.body);
                            scene.remove(item.mesh);

                            // Add a visual apple to the basket group
                            const collectedApple = new THREE.Mesh(
                                new THREE.SphereGeometry(0.4, 16, 16),
                                new THREE.MeshStandardMaterial({ color: 0xFF0000 })
                            );
                            collectedApple.position.set(
                                (Math.random() - 0.5) * 2,
                                1.5 + Math.random(),
                                (Math.random() - 0.5) * 2
                            );
                            // FIX: Tag for cleanup
                            collectedApple.userData.isCollectedApple = true;
                            robotMesh.add(collectedApple);

                            if (score >= maxItems) {
                                isGameActive = false;
                                confetti();
                                setTimeout(() => {
                                    document.getElementById('win-screen').classList.remove('hidden');
                                }, 1000);
                            }
                        }
                    }
                });
            }

            renderer.render(scene, camera);
        }
    </script>
</body>

</html>