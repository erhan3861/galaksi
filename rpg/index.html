<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Element RPG - Final</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;500;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Outfit', sans-serif;
            background-color: #1a1a1a;
            user-select: none;
            touch-action: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        /* HUD Elements */
        .hud-panel {
            position: absolute;
            background: rgba(20, 20, 30, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            color: white;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
        }

        #player-stats {
            top: 20px;
            left: 20px;
            width: 250px;
        }

        #quest-panel {
            top: 20px;
            right: 20px;
            text-align: right;
            max-width: 300px;
        }

        /* Bars */
        .bar-container {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            margin-top: 5px;
            overflow: hidden;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            width: 100%;
            transition: width 0.3s ease, background-color 0.3s ease;
        }

        .hp-fill {
            background: linear-gradient(90deg, #ff4d4d, #ff0000);
        }

        .xp-fill {
            background: linear-gradient(90deg, #ffd700, #ffaa00);
        }

        /* Level Up Menu */
        #levelup-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        #levelup-menu h1 {
            color: #ffd700;
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .perk-container {
            display: flex;
            gap: 20px;
            margin-top: 40px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .perk-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 16px;
            width: 200px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s, box-shadow 0.2s;
        }

        .perk-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .perk-title {
            font-weight: bold;
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        .perk-desc {
            font-size: 0.9em;
            opacity: 0.8;
            line-height: 1.4;
        }

        /* Game Over Screen */
        #game-over {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(50, 0, 0, 0.9);
            color: white;
            z-index: 30;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            font-size: 3rem;
            font-weight: bold;
        }

        /* Floating Damage Numbers */
        .damage-text {
            position: absolute;
            color: white;
            font-weight: bold;
            font-size: 1.2rem;
            pointer-events: none;
            animation: floatUp 1s forwards;
            text-shadow: 0 0 5px black;
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }

            100% {
                opacity: 0;
                transform: translateY(-50px) scale(1.2);
            }
        }

        /* Touch Controls */
        #joystick-zone {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
        }

        #attack-btn {
            position: absolute;
            bottom: 50px;
            right: 50px;
            width: 100px;
            height: 100px;
            background: rgba(255, 0, 0, 0.5);
            border: 4px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            color: white;
            user-select: none;
        }

        #attack-btn:active {
            background: rgba(255, 0, 0, 0.8);
            transform: scale(0.95);
        }

        #switch-btn {
            position: absolute;
            bottom: 170px;
            right: 50px;
            width: 60px;
            height: 60px;
            background: rgba(0, 100, 255, 0.5);
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
        }

        #switch-btn:active {
            background: rgba(0, 100, 255, 0.8);
            transform: scale(0.95);
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@23.1.3/dist/tween.esm.js",
                "nipplejs": "https://cdn.skypack.dev/nipplejs"
            }
        }
    </script>
</head>

<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div id="player-stats" class="hud-panel">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span style="font-size: 1.2em; font-weight: bold;">Player</span>
                <span id="level-display" style="color: #ffd700;">Lvl 1</span>
            </div>

            <div style="margin-top: 10px;">
                <div style="display: flex; justify-content: space-between; font-size: 0.8em;">
                    <span>HP</span>
                    <span id="hp-text">100/100</span>
                </div>
                <div class="bar-container">
                    <div id="hp-bar" class="bar-fill hp-fill"></div>
                </div>
            </div>

            <div style="margin-top: 8px;">
                <div style="display: flex; justify-content: space-between; font-size: 0.8em;">
                    <span>XP</span>
                    <span id="xp-text">0/100</span>
                </div>
                <div class="bar-container">
                    <div id="xp-bar" class="bar-fill xp-fill" style="width: 0%;"></div>
                </div>
            </div>

            <div style="margin-top: 10px; font-size: 0.8em; opacity: 0.8;">
                <div>üî• Fire: <span id="stat-fire">0</span></div>
                <div>üí® Wind: <span id="stat-wind">0</span></div>
                <div>üü§ Mud: <span id="stat-mud">0</span></div>
            </div>
        </div>

        <div id="quest-panel" class="hud-panel">
            <div style="font-weight: bold; margin-bottom: 5px; color: #ffd700;">CURRENT QUEST</div>
            <div id="quest-title" style="font-size: 1.1em; margin-bottom: 5px;">Loading...</div>
            <div id="quest-desc" style="font-size: 0.9em; opacity: 0.8;">Please wait.</div>
        </div>

        <div id="joystick-zone"></div>
        <div id="attack-btn" onpointerdown="playerAttack()">‚öîÔ∏è</div>
        <div id="switch-btn" onpointerdown="playerSwitch()">üîÑ</div>
    </div>

    <div id="levelup-menu">
        <h1>LEVEL UP!</h1>
        <p style="color: #ccc;">Stats increased by 10%. Choose a perk:</p>
        <div class="perk-container" id="perk-container"></div>
    </div>

    <div id="game-over">
        <div>GAME OVER</div>
        <div style="font-size: 1rem; margin-top: 20px; cursor: pointer; text-decoration: underline;"
            onclick="location.reload()">Try Again</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as TWEEN from '@tweenjs/tween.js';
        import nipplejs from 'nipplejs';

        // --- CONFIG & GLOBALS ---
        const CONFIG = {
            cameraOffset: new THREE.Vector3(0, 15, 15),
            colors: {
                ground: 0x2d5a27,
                player: 0x007fff,
                enemy: 0xff3333,
                xp: 0xffff00
            }
        };

        let scene, camera, renderer, clock;
        let player, enemies = [], xpOrbs = [], quests = [], slashEffects = [];
        let input = { x: 0, y: 0 }; // Joystick input
        let isGamePaused = false;
        let currentQuestIndex = 0;

        // --- SHADERS ---
        const glowingShader = {
            vertexShader: `
                varying vec3 vNormal;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec3 vNormal;
                uniform vec3 color;
                void main() {
                    float intensity = pow(0.7 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
                    gl_FragColor = vec4(color + intensity, 1.0);
                }
            `
        };

        // --- ENTITY CLASSES ---
        class Entity extends THREE.Group {
            constructor() {
                super();
                this.isDead = false;
            }
            update(dt) { }
        }

        class Player extends Entity {
            constructor() {
                super();
                this.level = 1;
                this.hp = 100;
                this.maxHp = 100;
                this.xp = 0;
                this.xpNeeded = 100;
                this.stats = { fire: 0, wind: 0, mud: 0 };
                this.isAttacking = false;

                // Mesh
                const geo = new THREE.CapsuleGeometry(0.5, 1.5, 4, 8);
                const mat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.player });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.position.y = 0.75;
                this.mesh.castShadow = true;
                this.add(this.mesh);

                // Eyes
                const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const leftEye = new THREE.Mesh(eyeGeo, eyeMat); leftEye.position.set(-0.2, 1.2, 0.4); this.mesh.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeo, eyeMat); rightEye.position.set(0.2, 1.2, 0.4); this.mesh.add(rightEye);

                // Weapon (Yatay Konumlu)
                this.swordMesh = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.2, 0.2), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                this.swordMesh.position.set(0.8, 0.7, 0.3);
                this.swordMesh.rotation.z = Math.PI / 2; // Yatay
                this.swordMesh.rotation.y = Math.PI / 4; // Hafif A√ßƒ±lƒ±
                this.mesh.add(this.swordMesh);
            }

            update(dt) {
                // Movement
                const speed = 5 + (this.stats.wind * 0.5);
                const dir = new THREE.Vector3(input.x, 0, input.y); // Joystick input

                if (dir.length() > 0.1) {
                    dir.normalize().multiplyScalar(speed * dt);
                    this.position.add(dir);

                    // Rotate to face movement direction
                    const targetRotation = Math.atan2(dir.x, dir.z);
                    this.mesh.rotation.y = targetRotation;
                }

                // Camera follow
                camera.position.copy(this.position).add(CONFIG.cameraOffset);
                camera.lookAt(this.position);
            }

            attack() {
                if (this.isAttacking) return;
                this.isAttacking = true;

                const startRot = { y: Math.PI / 4 };
                const targetRot = { y: -Math.PI / 2 };

                // Visual Effect
                const slashPos = this.position.clone().add(new THREE.Vector3(0, 1, 0));
                // Adjust slash rotation to match player facing
                const slash = new SlashEffect(slashPos, this.mesh.rotation.y);
                scene.add(slash);
                slashEffects.push(slash);

                // Tween
                new TWEEN.Tween(this.swordMesh.rotation)
                    .to(targetRot, 150)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .onComplete(() => {
                        new TWEEN.Tween(this.swordMesh.rotation)
                            .to(startRot, 150)
                            .easing(TWEEN.Easing.Quadratic.In)
                            .onComplete(() => {
                                this.isAttacking = false;
                            })
                            .start();
                    })
                    .start();

                // Hitbox
                enemies.forEach(e => {
                    if (this.position.distanceTo(e.position) < 3.5) {
                        // Check angle to ensure enemy is in front
                        const toEnemy = e.position.clone().sub(this.position).normalize();
                        const forward = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), this.mesh.rotation.y);
                        if (toEnemy.dot(forward) > 0.5) { // 60 degree cone roughly
                            e.takeDamage(10 + this.level * 2);
                            this.applyOnHit(e);
                        }
                    }
                });
            }

            switchWeapon() {
                spawnFloatingText("Weapon Switched!", this.position, '#fff');
            }

            applyOnHit(enemy) {
                if (this.stats.fire > 0) enemy.ignite(this.stats.fire * 5, 3);
                if (this.stats.mud > 0) enemy.slow(0.5, 2 + this.stats.mud);
            }

            addXp(amount) {
                this.xp += amount;
                if (this.xp >= this.xpNeeded) {
                    this.xp = 0;
                    this.xpNeeded = Math.ceil(this.xpNeeded * 1.2);
                    this.level++;
                    this.maxHp = Math.ceil(this.maxHp * 1.1);
                    this.hp = this.maxHp;
                    showLevelUpMenu();
                }
                updateUi();
            }

            takeDamage(amount) {
                this.hp -= amount;
                spawnFloatingText(Math.round(amount), this.position, '#ff0000');
                if (this.hp <= 0) {
                    this.hp = 0;
                    gameOver();
                }
                updateUi();
            }
        }

        class Enemy extends Entity {
            constructor(playerRef) {
                super();
                this.player = playerRef;
                this.baseSpeed = 2 + (Math.random() * 2);
                this.currentSpeed = this.baseSpeed;
                this.attackPower = 5 + (playerRef.level * 1);
                this.hp = 20 + (playerRef.level * 5);
                this.maxHp = this.hp;

                this.burnTimer = 0;
                this.burnDmg = 0;
                this.slowTimer = 0;
                this.attackCooldown = 0;

                const geo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                const mat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.enemy });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.castShadow = true;
                this.mesh.position.y = 0.4;
                this.add(this.mesh);

                this.hpBar = this.createHealthBar();
                this.hpBar.position.set(0, 1.2, 0);
                this.add(this.hpBar);
            }

            createHealthBar() {
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 8;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(0, 0, 64, 8);
                const tex = new THREE.CanvasTexture(canvas);
                const mat = new THREE.SpriteMaterial({ map: tex });
                const sprite = new THREE.Sprite(mat);
                sprite.scale.set(1, 0.125, 1);
                return sprite;
            }

            updateHealthBar() {
                const ratio = Math.max(0, this.hp / this.maxHp);
                const ctx = this.hpBar.material.map.image.getContext('2d');
                ctx.clearRect(0, 0, 64, 8);
                ctx.fillStyle = '#550000';
                ctx.fillRect(0, 0, 64, 8);
                ctx.fillStyle = `rgb(${Math.floor(255 * (1 - ratio))}, ${Math.floor(255 * ratio)}, 0)`;
                ctx.fillRect(0, 0, 64 * ratio, 8);
                this.hpBar.material.map.needsUpdate = true;
            }

            update(dt) {
                if (this.isDead) return;

                if (this.burnTimer > 0) {
                    this.burnTimer -= dt;
                    this.takeDamage(this.burnDmg * dt, true);
                    this.mesh.material.color.setHex(0xff8800);
                } else {
                    this.mesh.material.color.setHex(CONFIG.colors.enemy);
                }

                if (this.slowTimer > 0) {
                    this.slowTimer -= dt;
                    this.currentSpeed = this.baseSpeed * 0.5;
                    this.mesh.material.color.setHex(0x8b4513);
                } else {
                    this.currentSpeed = this.baseSpeed;
                }

                const dist = this.position.distanceTo(this.player.position);
                if (dist < 20) {
                    const dir = new THREE.Vector3().subVectors(this.player.position, this.position).normalize();
                    this.position.add(dir.multiplyScalar(this.currentSpeed * dt));
                    this.lookAt(this.player.position);

                    if (dist < 1.5) {
                        this.attack(dt);
                    }
                }
            }

            attack(dt) {
                if (this.attackCooldown > 0) {
                    this.attackCooldown -= dt;
                    return;
                }
                this.player.takeDamage(this.attackPower);
                this.attackCooldown = 1.0; // 1 second cooldown
            }

            ignite(dmg, duration) {
                this.burnTimer = duration;
                this.burnDmg = dmg;
            }

            slow(factor, duration) {
                this.slowTimer = duration;
            }

            takeDamage(amount, isDot = false) {
                this.hp -= amount;
                if (!isDot) {
                    spawnFloatingText(Math.round(amount), this.position, '#fff');
                    this.updateHealthBar();
                }
                if (this.hp <= 0) this.die();
            }

            die() {
                if (this.isDead) return;
                this.isDead = true;
                scene.remove(this);
                const orb = new XPOrb(this.position.clone(), 20 + this.player.level * 5);
                scene.add(orb);
                xpOrbs.push(orb);

                // Remove from array
                const idx = enemies.indexOf(this);
                if (idx > -1) enemies.splice(idx, 1);
            }
        }

        class XPOrb extends Entity {
            constructor(pos, amount) {
                super();
                this.amount = amount;
                this.position.copy(pos);
                this.position.y = 0.5;

                const mat = new THREE.ShaderMaterial({
                    uniforms: { color: { value: new THREE.Color(CONFIG.colors.xp) } },
                    vertexShader: glowingShader.vertexShader,
                    fragmentShader: glowingShader.fragmentShader,
                    transparent: true
                });

                this.mesh = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), mat);
                this.add(this.mesh);
                this.time = Math.random() * 100;
            }

            update(dt) {
                this.time += dt * 5;
                this.mesh.rotation.y += dt * 2;
                this.mesh.rotation.x += dt;
                this.position.y = 0.5 + Math.sin(this.time) * 0.2;

                if (this.position.distanceTo(player.position) < 2.0) {
                    player.addXp(this.amount);
                    this.isDead = true;
                    scene.remove(this);
                }
            }
        }

        class SlashEffect extends Entity {
            constructor(position, playerRotationY) {
                super();
                this.position.copy(position);
                this.rotation.y = playerRotationY;

                const geo = new THREE.RingGeometry(1.0, 2.5, 16, 1, Math.PI / 2, Math.PI);
                const mat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.rotation.x = -Math.PI / 2;
                this.add(this.mesh);

                this.life = 0.25;
            }

            update(dt) {
                this.life -= dt;
                if (this.life <= 0) {
                    this.isDead = true;
                    scene.remove(this);
                    return;
                }
                this.mesh.material.opacity = (this.life / 0.25);
                this.mesh.scale.multiplyScalar(1.05);
            }
        }

        // --- SYSTEM FUNCTIONS ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 10, 50);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            scene.add(dirLight);

            const groundGeo = new THREE.PlaneGeometry(100, 100);
            const groundMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.ground });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Trees
            for (let i = 0; i < 20; i++) {
                createTree((Math.random() - 0.5) * 80, (Math.random() - 0.5) * 80);
            }

            player = new Player();
            scene.add(player);

            setupQuests();

            // Joystick
            const manager = nipplejs.create({
                zone: document.getElementById('joystick-zone'),
                mode: 'static',
                position: { left: '50%', top: '50%' },
                color: 'white'
            });

            manager.on('move', (evt, data) => {
                if (data && data.vector) {
                    input.x = data.vector.x;
                    input.y = -data.vector.y; // NippleJS Y is inverted relative to 3D Z
                }
            });

            manager.on('end', () => {
                input.x = 0;
                input.y = 0;
            });

            window.addEventListener('resize', onWindowResize);

            // Expose functions for HTML buttons
            window.playerAttack = () => { if (!isGamePaused) player.attack(); };
            window.playerSwitch = () => { if (!isGamePaused) player.switchWeapon(); };
            window.selectPerk = selectPerk;

            clock = new THREE.Clock();
            updateUi();
            animate();

            // Spawn initial enemies
            setInterval(spawnEnemy, 3000);
        }

        function createTree(x, z) {
            const group = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.8, 2), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
            trunk.position.y = 1;
            group.add(trunk);

            const leaves = new THREE.Mesh(new THREE.ConeGeometry(2, 4), new THREE.MeshStandardMaterial({ color: 0x228B22 }));
            leaves.position.y = 3;
            group.add(leaves);

            group.position.set(x, 0, z);
            scene.add(group);
        }

        function setupQuests() {
            quests = [
                { title: "Find the Campfire", desc: "Go to the campfire marker.", pos: new THREE.Vector3(15, 0, 0), markerType: 'fire', done: false },
                { title: "Explore Forest", desc: "Reach the forest entrance.", pos: new THREE.Vector3(-15, 0, 20), markerType: 'cube', done: false },
                { title: "Secret Temple", desc: "Find the temple gate.", pos: new THREE.Vector3(0, 0, -18), markerType: 'cube', done: false },
                { title: "Legendary Weapon", desc: "Claim the ancient bow.", pos: new THREE.Vector3(0, 0, -25), markerType: 'cube', reward: 'bow', done: false }
            ];

            quests.forEach(q => {
                const geo = q.markerType === 'fire' ? new THREE.ConeGeometry(0.5, 1, 4) : new THREE.BoxGeometry(1, 1, 1);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                q.mesh = new THREE.Mesh(geo, mat);
                q.mesh.position.copy(q.pos);
                q.mesh.position.y = 0.5;
                scene.add(q.mesh);
            });

            updateQuestUi();
        }

        function updateQuestUi() {
            const q = quests[currentQuestIndex];
            const titleEl = document.getElementById('quest-title');
            const descEl = document.getElementById('quest-desc');

            if (q) {
                titleEl.innerText = q.title;
                descEl.innerText = q.desc;
            } else {
                titleEl.innerText = "All Quests Completed!";
                descEl.innerText = "You are a legend.";
            }
        }

        function checkQuests() {
            if (currentQuestIndex >= quests.length) return;
            const q = quests[currentQuestIndex];
            if (player.position.distanceTo(q.pos) < 3) {
                q.done = true;
                scene.remove(q.mesh);
                if (q.reward === 'bow') {
                    player.switchWeapon();
                    spawnFloatingText("UNLOCKED BOW!", player.position, '#ffd700');
                } else {
                    spawnFloatingText("QUEST COMPLETE!", player.position, '#00ff00');
                }
                currentQuestIndex++;
                updateQuestUi();
            }
        }

        function spawnEnemy() {
            if (enemies.length > 5) return;
            const angle = Math.random() * Math.PI * 2;
            const radius = 15 + Math.random() * 10; // Spawn further away
            const x = player.position.x + Math.sin(angle) * radius;
            const z = player.position.z + Math.cos(angle) * radius;
            const e = new Enemy(player);
            e.position.set(x, 0.4, z);
            scene.add(e);
            enemies.push(e);
        }

        function spawnFloatingText(text, pos, color) {
            const div = document.createElement('div');
            div.className = 'damage-text';
            div.innerText = text;
            div.style.color = color;
            const vec = pos.clone();
            vec.project(camera);
            const x = (vec.x * .5 + .5) * window.innerWidth;
            const y = (-(vec.y * .5) + .5) * window.innerHeight;
            div.style.left = `${x}px`;
            div.style.top = `${y}px`;
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 1000);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateUi() {
            document.getElementById('level-display').innerText = `Lvl ${player.level} `;
            document.getElementById('hp-text').innerText = `${Math.ceil(player.hp)}/${Math.ceil(player.maxHp)}`;
            document.getElementById('xp-text').innerText = `${player.xp}/${player.xpNeeded}`;
            const hpPct = (player.hp / player.maxHp) * 100;
            const xpPct = (player.xp / player.xpNeeded) * 100;
            document.getElementById('hp-bar').style.width = `${hpPct}%`;
            document.getElementById('xp-bar').style.width = `${xpPct}%`;
            document.getElementById('stat-fire').innerText = player.stats.fire;
            document.getElementById('stat-wind').innerText = player.stats.wind;
            document.getElementById('stat-mud').innerText = player.stats.mud;
        }

        function gameOver() {
            isGamePaused = true;
            document.getElementById('game-over').style.display = 'flex';
        }

        function selectPerk(type) {
            if (type === 'fire') player.stats.fire++;
            if (type === 'wind') player.stats.wind++;
            if (type === 'mud') player.stats.mud++;
            document.getElementById('levelup-menu').style.display = 'none';
            isGamePaused = false;
            updateUi();
        }

        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            TWEEN.update();

            if (!isGamePaused) {
                player.update(dt);

                // Update Entities
                enemies.forEach(e => e.update(dt));
                xpOrbs.forEach(o => o.update(dt));
                slashEffects.forEach(s => s.update(dt));

                checkQuests();
            }

            renderer.render(scene, camera);
        }

        init();

    </script>
</body>

</html>