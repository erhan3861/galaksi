<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <title>Misket Avcısı - Tam Sürüm</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Fredoka One', cursive;
            user-select: none;
            cursor: none;
            /* Hide default cursor */
        }

        #hud-container {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: row;
            gap: 20px;
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(5px);
            padding: 10px 30px;
            border-radius: 50px;
            border: 3px solid rgba(255, 255, 255, 0.6);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            z-index: 10;
            pointer-events: none;
        }

        .hud-item {
            display: flex;
            align-items: center;
            font-size: 24px;
            color: #fff;
            text-shadow: 2px 2px 0px #333;
        }

        .hud-icon {
            font-size: 32px;
            margin-right: 8px;
            filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.3));
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 0, 0, 0.8);
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
            z-index: 100;
        }

        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: red;
            border-radius: 50%;
        }

        #crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            border: 1px solid white;
            border-radius: 50%;
            opacity: 0.5;
        }

        #start-screen,
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 20;
            cursor: default;
        }

        .btn {
            padding: 15px 40px;
            font-size: 24px;
            background: #FFD700;
            color: #333;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 20px;
            font-family: 'Fredoka One', cursive;
            box-shadow: 0 6px 0 #d4af37;
            transition: transform 0.1s;
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #d4af37;
        }

        .hidden {
            display: none !important;
        }

        #combo-text {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #FFD700;
            text-shadow: 0 0 20px #FF4500;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
          "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
          "canvas-confetti": "https://cdn.skypack.dev/canvas-confetti"
        }
      }
    </script>
</head>

<body>

    <div id="hud-container">
        <div class="hud-item">
            <span class="hud-icon">⭐</span> <span id="score-text">0</span>
        </div>
        <div class="hud-item">
            <span class="hud-icon">❤️</span> <span id="lives-text">3</span>
        </div>
    </div>

    <div id="crosshair"></div>
    <div id="combo-text">COMBO!</div>

    <div id="start-screen">
        <h1 style="font-size: 60px; margin-bottom: 10px; text-shadow: 4px 4px 0 #000; color: #FFD700;">MİSKET AVCISI
        </h1>
        <p>Nişan al, ateş et ve misketleri düşür!</p>
        <button class="btn" id="btn-start">OYUNA BAŞLA</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 style="font-size: 50px; color: #FF6347;">OYUN BİTTİ!</h1>
        <h2 id="final-score">Skor: 0</h2>
        <button class="btn" onclick="location.reload()">TEKRAR OYNA</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';
        import confetti from 'canvas-confetti';

        // --- SES MOTORU (Web Audio API) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        const SoundManager = {
            playTone: (freq, type, duration, volume = 0.1) => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(volume, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },
            shoot: () => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            },
            hit: () => { SoundManager.playTone(400, 'square', 0.1, 0.1); },
            bonus: () => {
                SoundManager.playTone(800, 'sine', 0.1, 0.05);
                setTimeout(() => SoundManager.playTone(1200, 'sine', 0.2, 0.05), 100);
            }
        };

        // --- GLOBAL DEĞİŞKENLER ---
        let scene, camera, renderer, world;
        let time = 0;
        let isGameActive = false;
        let score = 0, lives = 3;

        const bullets = [];
        const marbles = [];
        const shaftParts = [];
        const lifterBodies = [];
        const lifterMeshes = [];

        // Ayarlar
        const numMarbles = 15;
        const numSteps = 8;
        const stepWidth = 1.6;
        const startX = -(numSteps * stepWidth) / 2 + 0.5;

        // Materyaller
        const woodMat = new THREE.MeshStandardMaterial({ color: 0xDEB887, roughness: 0.8 });
        const darkWoodMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
        const marbleMat = new THREE.MeshPhysicalMaterial({
            color: 0x00FFFF, metalness: 0.1, roughness: 0.1,
            transmission: 0.8, thickness: 1, clearcoat: 1
        });
        const bulletMat = new THREE.MeshStandardMaterial({ color: 0xFF0000, emissive: 0xFF0000, emissiveIntensity: 2 });

        const defaultPhysMat = new CANNON.Material('default');
        const marblePhysMat = new CANNON.Material('marble');

        // Input
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();

        init();
        animate();

        function init() {
            // 1. SAHNE
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 30, 100);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 30);
            camera.lookAt(0, 4, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // IŞIKLAR
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(10, 20, 15);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.set(2048, 2048);
            scene.add(dirLight);

            // 2. FİZİK
            world = new CANNON.World();
            world.gravity.set(0, -20, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.defaultContactMaterial.friction = 0.1;

            const marbleContact = new CANNON.ContactMaterial(defaultPhysMat, marblePhysMat, { friction: 0.05, restitution: 0.5 });
            world.addContactMaterial(marbleContact);

            createEnvironment();
            createMachine();

            document.getElementById('btn-start').addEventListener('click', startGame);
            window.addEventListener('mousedown', shoot);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);
        }

        function startGame() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            document.getElementById('start-screen').classList.add('hidden');
            isGameActive = true;
            document.body.style.cursor = 'none';

            let spawned = 0;
            const interval = setInterval(() => {
                if (spawned >= numMarbles) clearInterval(interval);
                else {
                    createMarble();
                    spawned++;
                }
            }, 1000);
        }

        function createEnvironment() {
            const groundGeo = new THREE.PlaneGeometry(200, 200);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x556B2F });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.5;
            ground.receiveShadow = true;
            scene.add(ground);

            const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: defaultPhysMat });
            groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            groundBody.position.y = -0.5;
            world.addBody(groundBody);
        }

        function createMachine() {
            const machineGroup = new THREE.Group();
            scene.add(machineGroup);

            // Base
            const baseGeo = new THREE.BoxGeometry(26, 1, 12);
            const base = new THREE.Mesh(baseGeo, woodMat);
            base.position.y = 0; base.receiveShadow = true;
            machineGroup.add(base);
            const baseBody = new CANNON.Body({ mass: 0, shape: new CANNON.Box(new CANNON.Vec3(13, 0.5, 6)), material: defaultPhysMat });
            baseBody.position.copy(base.position); world.addBody(baseBody);

            // Shaft
            const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 24, 16), darkWoodMat);
            shaft.rotation.z = Math.PI / 2; shaft.position.set(0, 4, 0); shaft.castShadow = true;
            machineGroup.add(shaft); shaftParts.push(shaft);

            // Pistons
            for (let i = 0; i < numSteps; i++) {
                const x = startX + (i * stepWidth);

                const cam = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 0.8, 16), darkWoodMat);
                cam.rotation.z = Math.PI / 2; cam.position.set(x, 4, 0);
                cam.geometry.translate(0, 0.5, 0);
                machineGroup.add(cam); shaftParts.push(cam);

                const lifterGroup = new THREE.Group();
                const pole = new THREE.Mesh(new THREE.BoxGeometry(1.2, 6, 0.8), woodMat);
                pole.position.y = 3; pole.castShadow = true;

                const topSlope = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 3), woodMat);
                topSlope.position.set(0, 6.2, 0);
                topSlope.rotation.x = -0.15;

                lifterGroup.add(pole, topSlope);
                lifterGroup.position.set(x, 3, 0);
                machineGroup.add(lifterGroup);
                lifterMeshes.push(lifterGroup);

                const lifterBody = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC, material: defaultPhysMat });
                lifterBody.addShape(new CANNON.Box(new CANNON.Vec3(0.75, 0.25, 1.5)));
                lifterBody.position.set(x, 6, 0);
                lifterBody.quaternion.setFromEuler(-0.15, 0, 0);
                lifterBody.userData = { initialY: 6, offset: i * 0.8 };
                world.addBody(lifterBody);
                lifterBodies.push(lifterBody);
            }

            // Return Ramp
            const returnRampBody = new CANNON.Body({ mass: 0, material: defaultPhysMat });
            returnRampBody.addShape(new CANNON.Box(new CANNON.Vec3(12, 0.1, 4)));
            returnRampBody.position.set(0, 1.5, 0);
            returnRampBody.quaternion.setFromEuler(0, 0, 0.1);
            world.addBody(returnRampBody);
        }

        function createMarble() {
            const radius = 0.5;
            // Random colors
            const color = new THREE.Color().setHSL(Math.random(), 1, 0.5);
            const mat = marbleMat.clone();
            mat.color = color;

            const mesh = new THREE.Mesh(new THREE.SphereGeometry(radius, 32, 32), mat);
            mesh.castShadow = true;
            scene.add(mesh);

            const shape = new CANNON.Sphere(radius);
            const body = new CANNON.Body({ mass: 5, shape: shape, material: marblePhysMat, linearDamping: 0.1, angularDamping: 0.1 });
            body.position.set(startX - 1, 8, 0);
            world.addBody(body);

            marbles.push({ mesh, body, active: true });
        }

        function onMouseMove(event) {
            // Update crosshair DOM element
            const crosshair = document.getElementById('crosshair');
            crosshair.style.left = event.clientX + 'px';
            crosshair.style.top = event.clientY + 'px';

            // Update mouse vector for raycasting
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function shoot() {
            if (!isGameActive) return;
            SoundManager.shoot();

            raycaster.setFromCamera(mouse, camera);
            const ray = raycaster.ray;

            // Shoot bullet from camera towards mouse world pos
            // Since we are in 3D, "mouse world pos" depends on depth.
            // Let's raycast against a plane at Z=0 (machine center) to find target point
            const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
            const target = new THREE.Vector3();
            ray.intersectPlane(plane, target);

            if (!target) return; // Should not happen looking at 0,0,0

            const dir = target.clone().sub(camera.position).normalize();

            const bulletRadius = 0.2;
            const mesh = new THREE.Mesh(new THREE.SphereGeometry(bulletRadius), bulletMat);
            mesh.position.copy(camera.position).add(dir.clone().multiplyScalar(2));
            scene.add(mesh);

            const body = new CANNON.Body({ mass: 2, shape: new CANNON.Sphere(bulletRadius) });
            body.position.copy(mesh.position);
            body.velocity.copy(dir.multiplyScalar(80));
            world.addBody(body);

            const bulletData = { mesh, body, createdAt: Date.now() };
            bullets.push(bulletData);

            body.addEventListener("collide", (e) => {
                const hitMarble = marbles.find(m => m.body === e.body);
                if (hitMarble && hitMarble.active) {
                    SoundManager.hit();
                    score += 10;
                    updateUI();

                    // Particle Effect
                    createParticles(hitMarble.mesh.position, hitMarble.mesh.material.color);

                    // Impulse
                    const impulse = dir.clone().multiplyScalar(30);
                    hitMarble.body.applyImpulse(new CANNON.Vec3(impulse.x, 5, impulse.z), hitMarble.body.position);

                    // Show Combo
                    const combo = document.getElementById('combo-text');
                    combo.style.opacity = 1;
                    combo.style.top = (window.innerHeight / 2 - 50) + 'px';
                    setTimeout(() => combo.style.opacity = 0, 500);
                }
            });
        }

        function createParticles(pos, color) {
            // Simple explosion
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const mat = new THREE.MeshBasicMaterial({ color: color });

            for (let i = 0; i < 5; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.position.x += (Math.random() - 0.5);
                mesh.position.y += (Math.random() - 0.5);
                scene.add(mesh);

                // Animate and remove
                // Simplified: just leave them for a sec
                setTimeout(() => scene.remove(mesh), 500);
            }
        }

        function updateUI() {
            document.getElementById('score-text').innerText = score;
            document.getElementById('lives-text').innerText = lives;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const dt = 1 / 60;
            world.step(dt);
            time += 0.05;

            if (!isGameActive) {
                renderer.render(scene, camera);
                return;
            }

            // Machine Animation
            shaftParts.forEach(p => p.rotation.x = time);
            for (let i = 0; i < numSteps; i++) {
                const body = lifterBodies[i];
                const mesh = lifterMeshes[i];
                const y = body.userData.initialY + Math.sin(time + body.userData.offset) * 0.9;
                body.position.y = y;
                mesh.position.copy(body.position);
                mesh.position.y -= 3;
            }

            // Marbles
            for (let i = 0; i < marbles.length; i++) {
                const m = marbles[i];
                m.mesh.position.copy(m.body.position);
                m.mesh.quaternion.copy(m.body.quaternion);

                if (m.body.position.y < -5) {
                    if (Math.abs(m.body.position.z) > 10 || Math.abs(m.body.position.x) > 20) {
                        m.body.velocity.set(0, 0, 0);
                        m.body.angularVelocity.set(0, 0, 0);
                        m.body.position.set(startX - 1, 8, 0);
                    } else {
                        if (m.body.position.x < startX + 2) {
                            m.body.velocity.set(0, 0, 0);
                            m.body.angularVelocity.set(0, 0, 0);
                            m.body.position.set(startX - 1, 8, 0);
                        }
                    }
                }
            }

            // Bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.mesh.position.copy(b.body.position);
                if (Date.now() - b.createdAt > 2000) {
                    world.removeBody(b.body); scene.remove(b.mesh);
                    bullets.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>

</html>