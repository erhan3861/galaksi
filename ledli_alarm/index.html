<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <title>Mor Maker: Led'li Alarm</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            background: #000;
            color: #0f0;
            user-select: none;
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #top-bar {
            display: flex;
            justify-content: center;
            gap: 30px;
            padding: 20px;
            background: linear-gradient(to bottom, rgba(0, 20, 0, 0.9), transparent);
            font-size: 24px;
            text-shadow: 0 0 10px #0f0;
        }

        .stat-box {
            background: rgba(0, 50, 0, 0.5);
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid #0f0;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.2);
        }

        #controls {
            pointer-events: auto;
            display: flex;
            justify-content: center;
            padding: 30px;
            gap: 30px;
            background: linear-gradient(to top, rgba(0, 20, 0, 0.9), transparent);
        }

        .game-btn {
            background: #004400;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 20px 40px;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 0 20px #0f0;
            font-family: 'Orbitron', sans-serif;
            transition: all 0.2s;
            border-radius: 5px;
            text-transform: uppercase;
            font-weight: bold;
        }

        .game-btn:hover {
            background: #006600;
            transform: scale(1.05);
            box-shadow: 0 0 30px #0f0;
        }

        .game-btn:active {
            transform: scale(0.95);
        }

        #joker-btn {
            border-color: #0ff;
            color: #0ff;
            box-shadow: 0 0 20px #0ff;
            background: #002222;
        }

        #joker-btn:hover {
            background: #004444;
            box-shadow: 0 0 30px #0ff;
        }

        #game-over,
        #win-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 0, 0.95);
            padding: 60px;
            border: 4px solid #f00;
            text-align: center;
            display: none;
            pointer-events: auto;
            color: #f00;
            box-shadow: 0 0 100px #f00;
            border-radius: 20px;
            z-index: 100;
        }

        #win-screen {
            border-color: #0f0;
            color: #0f0;
            box-shadow: 0 0 100px #0f0;
        }

        #instructions {
            position: absolute;
            top: 100px;
            width: 100%;
            text-align: center;
            color: rgba(0, 255, 0, 0.7);
            font-size: 18px;
            pointer-events: none;
        }

        .hidden {
            display: none !important;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>

    <div id="ui-container">
        <div id="top-bar">
            <div class="stat-box">LEVEL: <span id="level">1</span></div>
            <div class="stat-box">‚ù§Ô∏è Can: <span id="health">3</span></div>
            <div class="stat-box">‚è≥ S√ºre: <span id="time">60</span></div>
        </div>
        <div id="instructions">Aynalarƒ± √ßevirerek lazeri sens√∂re ula≈ütƒ±r!</div>
        <div id="controls">
            <button class="game-btn" id="fire-btn" onclick="fireLaser()">üî¥ ATE≈ûLE</button>
            <button class="game-btn" id="joker-btn" onclick="useJoker()">üîµ Hƒ∞ZALA</button>
        </div>
    </div>

    <div id="game-over">
        <h1>Sƒ∞STEM HATASI!</h1>
        <p style="font-size: 24px;">Lazer hedefe ula≈üamadƒ±.</p>
        <button class="game-btn" onclick="location.reload()">YENƒ∞DEN BA≈ûLAT</button>
    </div>

    <div id="win-screen" class="hidden">
        <h1>BA≈ûARILI!</h1>
        <p style="font-size: 24px;">Sens√∂r aktif edildi.</p>
        <button class="game-btn" id="next-level-btn">SONRAKƒ∞ SEVƒ∞YE</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        // Game State
        let level = 1;
        let health = 3;
        let time = 60;
        let gameActive = true;
        let laserActive = false;
        let jokerUsed = false;

        // Three.js Setup
        let scene, camera, renderer, composer;
        let mirrors = [];
        let source, target;
        let laserBeam;
        let raycaster, mouse;
        let hoveredMirror = null;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 35, 15);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild(renderer.domElement);

            // Post-processing (Bloom)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 2.0; // Strong glow
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Grid Floor
            const gridHelper = new THREE.GridHelper(50, 50, 0x004400, 0x001100);
            scene.add(gridHelper);

            // Lights
            const ambientLight = new THREE.AmbientLight(0x111111);
            scene.add(ambientLight);

            // Interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onWindowResize);

            document.getElementById('next-level-btn').addEventListener('click', nextLevel);

            window.fireLaser = fireLaser;
            window.useJoker = useJoker;

            createLevel(level);
        }

        function createLevel(lvl) {
            // Clear old
            mirrors.forEach(m => scene.remove(m));
            mirrors.length = 0;
            if (source) scene.remove(source);
            if (target) scene.remove(target);
            if (laserBeam) scene.remove(laserBeam);
            laserActive = false;

            document.getElementById('win-screen').classList.add('hidden');

            // Source (Laser Gun)
            const sourceGroup = new THREE.Group();
            const boxGeo = new THREE.BoxGeometry(2, 2, 2);
            const sourceMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const sourceMesh = new THREE.Mesh(boxGeo, sourceMat);
            sourceGroup.add(sourceMesh);

            // Barrel
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 2), new THREE.MeshBasicMaterial({ color: 0x333333 }));
            barrel.rotation.z = -Math.PI / 2;
            barrel.position.x = 1.5;
            sourceGroup.add(barrel);

            sourceGroup.position.set(-16, 1, -16);
            source = sourceGroup;
            scene.add(source);

            // Target (Sensor)
            const targetGroup = new THREE.Group();
            const targetMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const targetMesh = new THREE.Mesh(boxGeo, targetMat);
            targetGroup.add(targetMesh);

            // Dish
            const dish = new THREE.Mesh(new THREE.SphereGeometry(1.5, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2), new THREE.MeshBasicMaterial({ color: 0x004400, side: THREE.DoubleSide }));
            dish.rotation.x = -Math.PI / 2;
            dish.position.y = 1;
            targetGroup.add(dish);

            targetGroup.position.set(16, 1, 16);
            target = targetGroup;
            scene.add(target);

            // Mirrors
            const mirrorGeo = new THREE.BoxGeometry(3, 2.5, 0.5);
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5 });
            const glassMat = new THREE.MeshStandardMaterial({ color: 0x88ccff, metalness: 0.9, roughness: 0.1, emissive: 0x112233 });

            const numMirrors = 4 + lvl;
            const positions = [];

            // Grid positions
            for (let x = -12; x <= 12; x += 6) {
                for (let z = -12; z <= 12; z += 6) {
                    positions.push({ x, z });
                }
            }

            // Shuffle positions
            positions.sort(() => Math.random() - 0.5);

            for (let i = 0; i < numMirrors; i++) {
                if (i >= positions.length) break;

                const group = new THREE.Group();
                const frame = new THREE.Mesh(mirrorGeo, frameMat);
                group.add(frame);

                const glass = new THREE.Mesh(new THREE.PlaneGeometry(2.8, 2.3), glassMat);
                glass.position.z = 0.26;
                group.add(glass);

                const glassBack = new THREE.Mesh(new THREE.PlaneGeometry(2.8, 2.3), glassMat);
                glassBack.rotation.y = Math.PI;
                glassBack.position.z = -0.26;
                group.add(glassBack);

                const pos = positions[i];
                group.position.set(pos.x, 1.25, pos.z);

                // Random 45 deg rotation
                group.rotation.y = Math.floor(Math.random() * 4) * (Math.PI / 4);

                group.userData = { isMirror: true, baseColor: 0x333333 };
                scene.add(group);
                mirrors.push(group);
            }
        }

        function onMouseMove(event) {
            if (!gameActive) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(mirrors, true); // Recursive

            if (intersects.length > 0) {
                // Find parent group
                let obj = intersects[0].object;
                while (obj.parent && !obj.userData.isMirror) obj = obj.parent;

                if (hoveredMirror !== obj) {
                    if (hoveredMirror) hoveredMirror.children[0].material.emissive.setHex(0x000000);
                    hoveredMirror = obj;
                    hoveredMirror.children[0].material.emissive.setHex(0x004400);
                    document.body.style.cursor = 'pointer';
                }
            } else {
                if (hoveredMirror) {
                    hoveredMirror.children[0].material.emissive.setHex(0x000000);
                    hoveredMirror = null;
                    document.body.style.cursor = 'default';
                }
            }
        }

        function onMouseDown(event) {
            if (!gameActive || !hoveredMirror) return;
            hoveredMirror.rotation.y += Math.PI / 4;
        }

        function fireLaser() {
            if (!gameActive || laserActive) return;
            laserActive = true;

            const points = [];
            let origin = new THREE.Vector3(-14, 1, -16); // End of barrel
            let direction = new THREE.Vector3(1, 0, 0); // Start direction X+

            points.push(origin.clone());

            let hitTarget = false;
            let currentPos = origin.clone();
            let currentDir = direction.clone();

            // Raycast loop
            for (let i = 0; i < 15; i++) {
                const ray = new THREE.Raycaster(currentPos, currentDir);
                // Intersect mirrors and target
                // Need to intersect children meshes
                let objects = [];
                mirrors.forEach(m => objects.push(...m.children));
                objects.push(...target.children);

                const intersects = ray.intersectObjects(objects);

                if (intersects.length > 0) {
                    const hit = intersects[0];

                    // Check if hit point is "close enough" to start to avoid self-intersect
                    if (hit.distance < 0.1) {
                        // Skip this hit, look for next
                        // This is tricky. Simplified: Move start point slightly.
                        continue;
                    }

                    points.push(hit.point);

                    // Check if target
                    let obj = hit.object;
                    while (obj.parent && obj.parent !== scene) obj = obj.parent;

                    if (obj === target) {
                        hitTarget = true;
                        break;
                    } else if (obj.userData.isMirror) {
                        // Reflect
                        // Simple 90 degree reflection based on mirror angle
                        // Mirror angles: 0, 45, 90, 135
                        // 0 (|): Reflect X->-X, Z->Z? No, 0 is flat Z plane?
                        // Let's rely on normal reflection

                        // Get world normal
                        const n = hit.face.normal.clone();
                        n.transformDirection(hit.object.matrixWorld).normalize();

                        // Reflect: r = d - 2(d.n)n
                        currentDir.reflect(n);

                        // Snap to grid directions (0, 90, 180, 270) to avoid floating point drift
                        if (Math.abs(currentDir.x) > Math.abs(currentDir.z)) {
                            currentDir.x = Math.sign(currentDir.x);
                            currentDir.z = 0;
                        } else {
                            currentDir.x = 0;
                            currentDir.z = Math.sign(currentDir.z);
                        }

                        currentPos = hit.point.clone().add(currentDir.clone().multiplyScalar(0.1));
                    } else {
                        break; // Hit something else
                    }
                } else {
                    points.push(currentPos.clone().add(currentDir.multiplyScalar(100)));
                    break;
                }
            }

            // Draw Laser Mesh (Thick Line)
            if (laserBeam) scene.remove(laserBeam);

            // Create a tube geometry for glow
            const curve = new THREE.CatmullRomCurve3(points);
            curve.curveType = 'catmullrom';
            curve.tension = 0; // Straight lines

            // Actually TubeGeometry might be too rounded at corners. 
            // LineSegments with thick material?
            // Let's use simple Line for now but with Bloom it looks like laser
            const laserGeo = new THREE.BufferGeometry().setFromPoints(points);
            const laserMat = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });
            laserBeam = new THREE.Line(laserGeo, laserMat);

            // Add a glow mesh
            const tubeGeo = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(points), points.length, 0.2, 8, false);
            const tubeMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 });
            const glowMesh = new THREE.Mesh(tubeGeo, tubeMat);
            laserBeam.add(glowMesh);

            scene.add(laserBeam);

            setTimeout(() => {
                if (hitTarget) {
                    document.getElementById('win-screen').classList.remove('hidden');
                } else {
                    health--;
                    document.getElementById('health').innerText = health;
                    setTimeout(() => {
                        scene.remove(laserBeam);
                        laserActive = false;
                    }, 1000);
                    if (health <= 0) endGame();
                }
            }, 500);
        }

        function nextLevel() {
            level++;
            document.getElementById('level').innerText = level;
            time += 30;
            createLevel(level);
        }

        function useJoker() {
            if (!gameActive || jokerUsed) return;
            jokerUsed = true;
            document.getElementById('joker-btn').style.opacity = 0.5;

            // Cheat: Just win
            document.getElementById('win-screen').classList.remove('hidden');
        }

        function endGame() {
            gameActive = false;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').innerText = level;
        }

        setInterval(() => {
            if (gameActive && time > 0) {
                time--;
                document.getElementById('time').innerText = time;
                if (time <= 0) endGame();
            }
        }, 1000);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            composer.render();
        }
    </script>
</body>

</html>